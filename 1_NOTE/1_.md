1. 大型静态数组应该定义在全局，函数内定义容易爆栈
2. 为了避免纠结，一般不处理 ar[0]通常第n个就是ar[n]

#### 代码例题
- `1_1单向链表`:注意STL的`.end()`实际上是最后元素的迭代器+1
- `lt_92局部+全部反转链表`:使用了新的方法**添加额外头结点**
- `lt_23 合并k个链表`:使用了分治和优先队列两种方法

#### |单调队列&滑动窗口
<上册:p10-p15>
- `p1886滑动窗口/单调队列`:注意队列里保存的实际上是队列的下标
- `lt_53最大子列和问题`:使用了新的方法**线段树--开始回升思想**
- `p1440滑动窗口优先队列`:使用STL会超时，非常神奇
- `p2422优先队列`:只有50分，目前尚未解决
##### 单调队列优化DP
- `p3957二分法+DP动态规划+单调队列优化`:关键在于**单调队列优化DP**
- `p1725 DP动态规划+单调队列优化`:关键在于->有些点根本跳不到

- `p1175中缀转后缀表达式`:其中_1是STL方法，_2是C的表达式树方法
---

##### C++17推导指引
```cpp
    lists.erase(remove_if(lists.begin(), lists.end(), [](auto p) { return !p; }), lists.end());
    priority_queue q{ [](auto& a, auto& b) { return a->val > b->val; }, lists };
```
