1. 大型静态数组应该定义在全局，函数内定义容易爆栈
2. 为了避免纠结，一般不处理 ar[0]通常第n个就是ar[n]

#### 代码例题
- `1_1单向链表`:注意STL的`.end()`实际上是最后元素的迭代器+1
- `lt_92局部+全部反转链表`:使用了新的方法**添加额外头结点**
- `lt_23 合并k个链表`:使用了分治和优先队列两种方法

#### |单调队列&滑动窗口
<上册:p10-p15>
- `p1886滑动窗口/单调队列`:注意队列里保存的实际上是队列的下标
- `lt_53最大子列和问题`:使用了新的方法**线段树--开始回升思想**
- `p1440滑动窗口优先队列`:使用STL会超时，非常神奇
- `p2422优先队列`:只有50分，目前尚未解决
##### 单调队列优化DP
- `p3957二分法+DP动态规划+单调队列优化`:关键在于**单调队列优化DP**
- `p1725 DP动态规划+单调队列优化`:关键在于->有些点根本跳不到

- `p1175中缀转后缀表达式`:其中_1是STL方法，_2是C的表达式树方法
- `hdu2527简单哈夫曼WSL计算`

- `p5018判断对称二叉树`:B法说明，有时不用链表惯性思维进行有序遍历，而是发挥数组二叉树的神奇特性->遍历
- `p3045优惠劵买奶牛`属于**反悔贪心算法**说明贪心的适用条件是局部最优解即为全局最优解
---


##### C++17推导指引
```cpp
    lists.erase(remove_if(lists.begin(), lists.end(), [](auto p) { return !p; }), lists.end());
    priority_queue q{ [](auto& a, auto& b) { return a->val > b->val; }, lists };
```

##### 头文件/预定义
```cpp
//定义long long的别名
typedef long long llg;
const llg INF = 2147483647;

//用于从重定向0_in/a.in和0_out/a.out读取文件
#define yyj(a) freopen("0_in/"a".in","r",stdin),freopen("0_out/"a".out","w",stdout);

//读取一个整数
inline llg getint()
{
    llg w=0,q=0; char c=getchar();
    while((c<'0' || c>'9') && c!='-') c=getchar();
    if (c=='-')  q=1, c=getchar(); while (c>='0' && c<='9') w=w*10+c-'0', c=getchar();
    return q ? -w : w;
}

```

##### 一种散列值计算
```cpp
#define V1 (llg)(999999751) 
#define V2 (llg)(299999827) 
#define V3 (llg)(100000007)
#define md (llg)(89999794200117649)
#define mdd (llg)(999999786000011449)

//这里把lson[x]进行替换
hal[x] = (hal[lson[x]] * V1 + val[x] * V2 + hal[rson[x]] * V3) % md;
Hal[x] = (Hal[lson[x]] * V1 + val[x] * V2 + Hal[rson[x]] * V3) % mdd;
```
