1. 大型静态数组应该定义在全局，函数内定义容易爆栈
2. 为了避免纠结，一般不处理 ar[0]通常第n个就是ar[n]

#### 代码例题
- `1_1单向链表`:注意STL的`.end()`实际上是最后元素的迭代器+1
- `lt_92局部+全部反转链表`:使用了新的方法**添加额外头结点**
- `lt_23 合并k个链表`:使用了分治和优先队列两种方法

### |1.单调队列&滑动窗口
<上册:p10-p15>
- `p1886滑动窗口/单调队列`:注意队列里保存的实际上是队列的下标
- `lt_53最大子列和问题`:使用了新的方法**线段树--开始回升思想**
- `p1440滑动窗口优先队列`:使用STL会超时，非常神奇
- `p2422优先队列`:只有50分，目前尚未解决
---

### |2.单调队列优化DP
- `p3957二分法+DP动态规划+单调队列优化`:关键在于**单调队列优化DP**
- `p1725 DP动态规划+单调队列优化`:关键在于->有些点根本跳不到

- `p1175中缀转后缀表达式`:其中_1是STL方法，_2是C的表达式树方法
- `hdu2527简单哈夫曼WSL计算`
---

- `p5018判断对称二叉树`:B法说明，有时不用链表惯性思维进行有序遍历，而是发挥数组二叉树的神奇特性->遍历
- `p3045优惠劵买奶牛`属于**反悔贪心算法**说明贪心的适用条件是局部最优解即为全局最优解

### |3.尺取法
- 同向扫描:寻找区间和
  ```cpp
  for(int i=1;i<=n;i++){
    while(j<=n && a[j]-a[i]<c) j++;
    while(k<=n && a[k]-a[i]<=c) k++;
    if(a[j]-a[i]==c && a[k-1]-a[i]==c
        && k-1>=1/*易错:确保k是大于1的否则会越界*/)
        ans += k-j;
  }
  ```
- 反向扫描:求a+b==m的问题
  ```cpp
  while(i<j){
    if(sum>m) j--; if(sum<m) i++;
    if(sum==m){
        /*--此处处理--*/
        i++; //🟠易错:可能有多个答案，继续
    }
  }
  ```
- `hdu5358尺取法求二进制位数`中间过程间接使用尺取法，并不是直接使用
- `p1102找A-B=C的数对个数`使用暴力map，题目变更为找A-C在数对中的个数
---

### |4.二分法
- 整数二分:**注意终止边界|左右区间开闭情况**
- 实数二分：**注意精度问题**


#### A-整数二分
有关于二分法的问题特别容易出错，因为分为**后继**和**前驱**两种模式：
##### 后继模板代码
后继找的是左中位数
```cpp
int bin_search(int* ar,int n,int x){
  int l=0,r=n; //这里确保r是取不到的！！
  while(l<r){
    int mid = (l+r)>>1; //或者 l+(r-l)/2
    if(ar[mid]>=x) r=mid;
    else l=mid+1;
  }
  return l;
}
```
##### 前驱模板代码
前驱找的是右中位数
```cpp
int bin_search2(int* ar,int n,int x){
  int l=0,r=n;
  while(l<r){
    int mid = (l+r+1)>>1; //或者 l+(r-l+1)/2
    if(ar[mid]<=x) l=mid;
    else r=mid-1;
  }
  return l;
}
```
如下是几个关键问题:
1. 不要把`l=mid+1`和`r=mid-1`写成mid，会导致死循环
2. 注意不同问题下的mid取值，严格区分左中位数还是右中位数
3. 寻找mid推荐有：**因为除法正数向下取整，负数向上取整**
   - `mid=(l+r)/2` 适用于: `l>=0 && r>=0 && l+r < MAX`
                  问题:a.负数情况下有向0取整的问题 b.`l+r`有可能溢出
   - `mid=l+(r-l)/2`适用于:`r-l < MAX`
                  问题:若r和l都大数且一正一负，则`r-l`可能溢出
   - `mid=(l+r)>>1`适用于:`l+r<MAX`
                  问题:若r和l都是大数，则`l+r`可能溢出

##### 整数二分建模



#### B-实数二分



---

---

## 附录:

### |`lower_bound`&&`upper_bound`
- `lower_bound`>=x的地址
- `upper_bound`>x的地址
> 注意:当`a[n-1]<key`时，`l_d()`返回的也是n

因为返回的是地址，因此如果需要获得下标，还需要减去数组首元素的地址
如下是几个常用的使用方法:
- 查找最后一个等于/小于x的数:`u_b()前一个`
- 计算单调序列中x的个数:`u_b()-l_b()`
  
### |C++17推导指引
```cpp
    lists.erase(remove_if(lists.begin(), lists.end(), [](auto p) { return !p; }), lists.end());
    priority_queue q{ [](auto& a, auto& b) { return a->val > b->val; }, lists };
```


---

## 头文件/预定义

### |快读和重定向
```cpp
//定义long long的别名
typedef long long llg;
const llg INF = 2147483647;

//用于从重定向0_in/a.in和0_out/a.out读取文件
#define yyj(a) freopen("0_in/"a".in","r",stdin),freopen("0_out/"a".out","w",stdout);

//读取一个整数
inline llg getint()
{
    llg w=0,q=0; char c=getchar();
    while((c<'0' || c>'9') && c!='-') c=getchar();
    if (c=='-')  q=1, c=getchar(); while (c>='0' && c<='9') w=w*10+c-'0', c=getchar();
    return q ? -w : w;
}

```

### |一种散列值计算
```cpp
#define V1 (llg)(999999751) 
#define V2 (llg)(299999827) 
#define V3 (llg)(100000007)
#define md (llg)(89999794200117649)
#define mdd (llg)(999999786000011449)

//这里把lson[x]进行替换
hal[x] = (hal[lson[x]] * V1 + val[x] * V2 + hal[rson[x]] * V3) % md;
Hal[x] = (Hal[lson[x]] * V1 + val[x] * V2 + Hal[rson[x]] * V3) % mdd;
```

### |时间复杂度
|       |×复杂度    |n<=11 |n<=25 |n<=5000 |n<10e6 |n<10e7 |n>10e8 |
|----------|------|------|--------|-------|-------|-------|
|O(log2n)  |✓     |✓     |✓       |✓      |✓      |✓      |
|O(1)      |✓     |✓     |✓       |✓      |✓      |✓      |
|O(n)      |✓     |✓     |✓       |✓      |✓      |×      |
|O(n log n)|✓     |✓     |✓       |✓      |×      |×      |
|O(n^2)    |✓     |✓     |✓      |×      |×      |
|O(n^3)    |✓     |✓     |×       |×      |×      |×      |
|O(2^n)    |✓     |✓     |×       |×      |×      |×      |
|O(n!)     |✓     |×     |×       |×      |×      |×      |

