
## A|经典线性DP


> 警告：DP尽量只使用自我滚动，尤其在分组背包中，不能使用交替滚动

#### 1|分组背包
- `hdu1712 -- 线性DP-分组背包`:有时候会遇到物品'体积'就是日期之类，哪怕`c[i][k]==k`也不要偷懒不写c[][]，否则会把自己绕昏
```cpp
/** 
 * 0/1背包问题必要分析：
 * n=? C=?
 * i| (w) c (m)
 * -|----------
 * 1| 
 * 2| 
 * 3| 
 * 4| 
 * 
 * a.若无明确w，则w为c
 * b.若有m，使用二进制拆分优化
*/
for(int j=m;j>=0;j--)
    for(int k=1;k<=m;k++)
        if(j>=c[i][k])
            dp[j]=max(do[j],dp[j-c[i][k]]+w[i][k])
/**
 * 对于分组背包问题，已经相当于两层DP
 * 否则对于for(k:m)的每一个k
 * 也必须进行一次swap(cur_,old_)
 * /
```

#### 2|多重背包
##### 二进制拆分优化
- `p2347 -- 多重背包 + 二进制拆分优化`:核心算法使用**二进制拆分优化**，比较套路化，找出w/c/m和new_w/new_c即可，但是仍然有易错点————`for(int j=C;j>=new_c[i];j--)`缺少判断范围是否能减去

#### 3|最长公共子序列LCS
- `hdu1159 最长公共子序列问题`：万变不离最基本的DP，只不过dp状态方程比较难以找出

#### 4|最长递增子序列LIS
- `lt300`:使用两种方法：**A:常规DP方法**和**B:扑克二分法**
##### 4.a|扑克二分法
利用的思想是扑克接龙，用一个单调递增的序列当做能接龙的扑克数<br>
其中堆的数量就是最长递增子序列
详细见[labuladong--DP精讲](https://labuladong.github.io/algo/di-er-zhan-a01c6/dong-tai-g-a223e/dong-tai-g-6ea57/)
- `lt354 俄罗斯套娃信封问题`：主要是LIS在二维上的使用，主要原理是通过排序，让LIS在单一维度上进行使用

#### 5|编辑距离(两字符串编辑使相同)
- `p2758 两字符串编辑相同距离`:使用dp[i][j]表示从word1[i]到word2[j]的最少编辑次数，注意需要初始化`dp[old][j]=j && dp[cur][0]=i`

#### 6|最小划分(分成两组)
- `lc724`:当数据需要划分为两组时，即转为0/1背包问题(只有在背包和不在背包的)，此时数值大小即为体积，价值也是体积

#### 7|行走问题(1~3台阶)
一个人每次每次能走1-3步，问走到n有多少种走法？——实际上是一个斐波那契问题，使用动态规划：
```cpp
dp[0]=1,dp[1]=1,dp[2]=2
dp[i]=dp[i-1]+dp[i-2]+dp[i-3] //i>2
```

#### 8|矩阵最长递增路径
- `lt329`:给定一个矩阵，找到最长一条路径——使用记忆化DFS(但是在递归前要判断是否是递增路径)
  
#### 9|子集和问题
- 若求一个集合中两个数字和为M，则使用双指针。
- 若求一个集合的子集和为M，则需要使用dp:<br>
    这是一个0-1背包，让C=M即可
  1. S[i]>j 无法放入子集，dp[i][j]=dp[i-1][j]
  2. S[i]<j ，则dp[i][j]=max(dp[i-1][j],dp[i-1][j-S[i]])
   注意：这个没有w奖励，而是只有0-1两种，因为初始化为dp[i][0]=1

#### 10|最优游戏策略
有关于二人博弈的问题(校赛题目)，两人交替拿硬币，求先手的最大价值是v={8,15,3,7}：
1. 不能使用贪心法，因为先拿8，对手就可以拿15
2. 不能使用BFS，因为指数级复杂度
3. 只能使用DP，但是状态转移方程比较奇特<br>
    定义dp[i][j]为从第i堆到j堆先手能拿到的最大值，此时
    ```cpp
    dp[i][j]=max(
        V[i]+min(dp[i+2][j],dp[i+1][j-1]),
        V[j]+min(dp[i+1][j-1],dp[i][j-2])
    )  
    dp[i][j]=V[i], j=i
    dp[i][j]=max(V[i],V[j]),j=i+1
    ```
    这需要一个关键的理念————**对手必然选择对先手不利的拿法**————意味着先手在第二次拿的时候，一定是最小的


### |其他题目
- `p4158 刷n木板m格子问题`:这道题要DP两次，单个木板DP，木板间也DP，易错在于不能轻易DP压缩，而要有`dp[i][j][color[i]]`和`dp[i][j][!color[i]]`
- `p2501成为单调序列的最小修改次数`:并不是直接带入DP思路去分析，而是中途使用DP nj

------------------------------------------------------------

## B|数位统计DP