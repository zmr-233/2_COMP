
## A|经典线性DP


> 警告：DP尽量只使用自我滚动，尤其在分组背包中，不能使用交替滚动

#### 1|分组背包
- `hdu1712 -- 线性DP-分组背包`:有时候会遇到物品'体积'就是日期之类，哪怕`c[i][k]==k`也不要偷懒不写c[][]，否则会把自己绕昏
```cpp
/** 
 * 0/1背包问题必要分析：
 * n=? C=?
 * i| (w) c (m)
 * -|----------
 * 1| 
 * 2| 
 * 3| 
 * 4| 
 * 
 * a.若无明确w，则w为c
 * b.若有m，使用二进制拆分优化
*/
for(int j=m;j>=0;j--)
    for(int k=1;k<=m;k++)
        if(j>=c[i][k])
            dp[j]=max(do[j],dp[j-c[i][k]]+w[i][k])
/**
 * 对于分组背包问题，已经相当于两层DP
 * 否则对于for(k:m)的每一个k
 * 也必须进行一次swap(cur_,old_)
 * /
```

#### 2|多重背包
##### 二进制拆分优化
- `p2347 -- 多重背包 + 二进制拆分优化`:核心算法使用**二进制拆分优化**，比较套路化，找出w/c/m和new_w/new_c即可，但是仍然有易错点————`for(int j=C;j>=new_c[i];j--)`缺少判断范围是否能减去

#### 3|最长公共子序列LCS
- `hdu1159 最长公共子序列问题`：万变不离最基本的DP，只不过dp状态方程比较难以找出

#### 4|最长递增子序列LIS
- `lt300`:使用两种方法：**A:常规DP方法**和**B:扑克二分法**
##### 4.a|扑克二分法
利用的思想是扑克接龙，用一个单调递增的序列当做能接龙的扑克数<br>
其中堆的数量就是最长递增子序列
详细见[labuladong--DP精讲](https://labuladong.github.io/algo/di-er-zhan-a01c6/dong-tai-g-a223e/dong-tai-g-6ea57/)
- `lt354 俄罗斯套娃信封问题`：主要是LIS在二维上的使用，主要原理是通过排序，让LIS在单一维度上进行使用

#### 5|编辑距离(两字符串编辑使相同)
- `p2758 两字符串编辑相同距离`:使用dp[i][j]表示从word1[i]到word2[j]的最少编辑次数，注意需要初始化`dp[old][j]=j && dp[cur][0]=i`

#### 6|最小划分(分成两组)
- `lc724`:当数据需要划分为两组时，即转为0/1背包问题(只有在背包和不在背包的)，此时数值大小即为体积，价值也是体积

#### 7|行走问题(1~3台阶)
一个人每次每次能走1-3步，问走到n有多少种走法？——实际上是一个斐波那契问题，使用动态规划：
```cpp
dp[0]=1,dp[1]=1,dp[2]=2
dp[i]=dp[i-1]+dp[i-2]+dp[i-3] //i>2
```

#### 8|矩阵最长递增路径
- `lt329`:给定一个矩阵，找到最长一条路径——使用记忆化DFS(但是在递归前要判断是否是递增路径)
  
#### 9|子集和问题
- 若求一个集合中两个数字和为M，则使用双指针。
- 若求一个集合的子集和为M，则需要使用dp:<br>
    这是一个0-1背包，让C=M即可
  1. S[i]>j 无法放入子集，dp[i][j]=dp[i-1][j]
  2. S[i]<j ，则dp[i][j]=max(dp[i-1][j],dp[i-1][j-S[i]])
   注意：这个没有w奖励，而是只有0-1两种，因为初始化为dp[i][0]=1

#### 10|最优游戏策略
有关于二人博弈的问题(校赛题目)，两人交替拿硬币，求先手的最大价值是v={8,15,3,7}：
1. 不能使用贪心法，因为先拿8，对手就可以拿15
2. 不能使用BFS，因为指数级复杂度
3. 只能使用DP，但是状态转移方程比较奇特<br>
    定义dp[i][j]为从第i堆到j堆先手能拿到的最大值，此时
    ```cpp
    dp[i][j]=max(
        V[i]+min(dp[i+2][j],dp[i+1][j-1]),
        V[j]+min(dp[i+1][j-1],dp[i][j-2])
    )  
    dp[i][j]=V[i], j=i
    dp[i][j]=max(V[i],V[j]),j=i+1
    ```
    这需要一个关键的理念————**对手必然选择对先手不利的拿法**————意味着先手在第二次拿的时候，一定是最小的


### |其他题目
- `p4158 刷n木板m格子问题`:这道题要DP两次，单个木板DP，木板间也DP，易错在于不能轻易DP压缩，而要有`dp[i][j][color[i]]`和`dp[i][j][!color[i]]`
- `p2501成为单调序列的最小修改次数`:并不是直接带入DP思路去分析，而是中途使用DP nj

------------------------------------------------------------

## B|数位统计DP
虽然不难，但是最大的特点是容易错：
1. 易错：统计区间[a,b]是[1,a-1]与[1,b]的差分，不要一下子写成solve(a,cnta)
2. 有两种方式得到dp[i]--即**为i位数的每种数字有多少个**：
   ```cpp
   dp[i]=dp[i-1]*10+10^(i-1)/*使用递推方式得到
   在十位个位一共dp[i-1]，外加百位的出现10^(i-1)个 */
   dp[i]=i*10^(i)/10 /*使用排列组合思想得到
   "数位"是指00-99,一共100个数字，但是每个数贡献2个数位，即为2*100=200*/
   ```
3. 易错:这里是一视同仁把前导0也视为数字，最后需要去除

- `p2602 A-数位统计DP  递推实现`:以[0,324]为例，说明每种数字的cnt:
  ```cpp
    const int N = 18;
    llg ten[N],dp[N];
    llg cnta[N],cntb[N];
    llg num[N];
    void init(){
        ten[0]=1;
        for(int i=1;i<N;i++){
            dp[i]=i*ten[i-1];
            ten[i]=10*ten[i-1];
        }
    }
    void solve(llg x,llg* cnt){
        int len=0;
        while(x){
            num[++len]=x%10;
            x/=10;
        }
        for(int i=len;i>=1;i--){
            //A-常规：小一位
            for(int j=0;j<=9;j++) cnt[j] += dp[i-1]*num[i];
            //B-最高位：小于num[i]
            for(int j=0/*包含0*/;j<num[i];j++) cnt[j] += ten[i-1];
            //C-最高位：刚好是num[i]
            llg tmp=0;
            for(int j=i-1;j>=1;j--) tmp = 10*tmp + num[j];
            cnt[num[i]] += tmp +1 ;
            /*ERROR:
            cnt[num[i]] += tmp; 这里缺少了300这种情况
            应当+1l
            */
            //最后处理--去除前缀0
            cnt[0]-=ten[i-1]; //这里已经相当于1*ten[i-1]
        }
    }
  ```

- `p2602 B-数位统计DP  记忆化搜索实现`:使用记忆化搜索比较难，建议看书，模板代码如下：
  ```cpp
    const int N=15;
    llg dp[N][N];
    int num[N],now; //now:统计的是当前0-9的哪一个数字

    llg dfs(int pos,int sum,bool lead,bool limit){ //pos:当前处理到第pos位
        if(pos==0) return sum; //递归到0位，结束
        if(!lead && !limit && dp[pos][sum]!=-1) return dp[pos][sum]; //记忆化搜索
        
        int up = (limit?num[pos]:9); //这一位的最大值，如324第3位就是Up=3
        llg ans=0; //下面以324 now=2(pos=3)为例
        for(int i=0;i<=up;i++){
            //A-计算000-099
            if(i==0 && lead) ans += dfs(pos-1,sum,true,limit && i==up);
            //B-计算200-299
            else if(i==now) ans += dfs(pos-1,sum+1,false,limit && i==up);
            //C-计算100-199
            else if(i!=now) ans += dfs(pos-1,sum,false,limit && i==up);
        }
        if(!lead && !limit) dp[pos][sum]=ans; //注意：有且只有无前导且无数位限制，才能放入dp
        return ans;
    }
    llg solve(llg x){
        int len=0;
        while(x){
            num[++len]=x%10;
            x/=10;
        }
        memset(dp,-1,sizeof(dp));
        return dfs(len,0,true,true);
    }
  ```

#### 数位统计例题
- `p2657 Windy数abs(a-b)>=2`:定义状态dp[pos][last]表示数字长度在pos，前一位在last的情况下，数字的个数(注意初始化的last=-2)
- `p4124 手机号码问题`:定义状态dp[pos][u][v][state][n8][n4],其中u是前一位数字，v是前两位数字,state是否满足连续三位数字，n8则是是否有8，n4是否有4;; 最重要的核心是，这道题采用了**回避前导0省去lead变量**直接从solve遍历首数字

#### 数位统计经验怪谈
1. 至少可以看出为了能够递归，是从外部到内部的，通常一个函数的返回值就是答案
2. dp状态是要按照题目要求去构建的，而不是只有`dp[pos][sum]`这样的形式
3. 可以通过solve()直接对首字母for来回避前导0问题————省去了lead变量
